const express = require('express');
const { createServer } = require('http');
const { Server } = require('socket.io');
const jwt = require('jsonwebtoken');
const cors = require('cors');
const { PrismaClient } = require('@prisma/client');
require('dotenv').config();

const prisma = new PrismaClient();
const app = express();
const httpServer = createServer(app);

// Middleware
app.use(cors({
  origin: [
    'http://localhost:3000',
    'http://localhost:5173',
    'https://mirchan.netlify.app',
		'https://mirchan.site',
		'https://mirchan-express-api.vercel.app',
    process.env.FRONTEND_URL
  ].filter(Boolean),
  credentials: true
}));
app.use(express.json());

// âœ… Ð’Ð¡Ð¯ Ð›ÐžÐ“Ð˜ÐšÐ Ð˜Ð— express-api/socket.js Ð‘Ð•Ð— Ð˜Ð—ÐœÐ•ÐÐ•ÐÐ˜Ð™
class SocketManager {
  constructor() {
    this.io = null;
    this.userSockets = new Map(); // userId -> socketId
    this.socketUsers = new Map(); // socketId -> userId
  }

  init(server) {
    this.io = new Server(server, {
      cors: {
        origin: [
          'http://localhost:3000',
          'http://localhost:5173',
          'https://mirchan.netlify.app',
          'https://mirchan-express-api.vercel.app',
          process.env.FRONTEND_URL
        ].filter(Boolean),
        credentials: true,
        methods: ['GET', 'POST']
      }
    });

    // Middleware Ð´Ð»Ñ Ð°ÑƒÑ‚ÐµÐ½Ñ‚Ð¸Ñ„Ð¸ÐºÐ°Ñ†Ð¸Ð¸
    this.io.use(async (socket, next) => {
      try {
        const token = socket.handshake.auth.token;
        if (!token) {
          return next(new Error('Authentication error'));
        }

        const decoded = jwt.verify(token, process.env.SECRET_KEY);
        const user = await prisma.user.findUnique({
          where: { id: decoded.userId },
          select: { id: true, name: true, email: true, avatarUrl: true }
        });

        if (!user) {
          return next(new Error('User not found'));
        }

        socket.userId = user.id;
        socket.user = user;
        next();
      } catch (error) {
        console.error('Socket authentication error:', error);
        next(new Error('Authentication error'));
      }
    });

    this.io.on('connection', (socket) => {
      console.log(`User ${socket.user.name} connected:`, socket.id);
      
      // ÐžÐ±Ð½Ð¾Ð²Ð»ÑÐµÐ¼ Ð²Ñ€ÐµÐ¼Ñ Ð¿Ð¾ÑÐ»ÐµÐ´Ð½ÐµÐ¹ Ð°ÐºÑ‚Ð¸Ð²Ð½Ð¾ÑÑ‚Ð¸
      this.updateUserLastSeen(socket.userId);
      
      // Ð¡Ð¾Ñ…Ñ€Ð°Ð½ÑÐµÐ¼ ÑÐ¾ÐµÐ´Ð¸Ð½ÐµÐ½Ð¸Ðµ Ð¿Ð¾Ð»ÑŒÐ·Ð¾Ð²Ð°Ñ‚ÐµÐ»Ñ
      this.userSockets.set(socket.userId, socket.id);
      this.socketUsers.set(socket.id, socket.userId);

      // ÐŸÑ€Ð¸ÑÐ¾ÐµÐ´Ð¸Ð½ÐµÐ½Ð¸Ðµ Ðº ÐºÐ¾Ð¼Ð½Ð°Ñ‚Ð°Ð¼ Ð¿Ð¾Ð»ÑŒÐ·Ð¾Ð²Ð°Ñ‚ÐµÐ»Ñ (ÐµÐ³Ð¾ Ñ‡Ð°Ñ‚Ñ‹)
      this.joinUserChats(socket);

      // Ð£Ð²ÐµÐ´Ð¾Ð¼Ð»ÑÐµÐ¼ Ð²ÑÐµÑ… ÑƒÑ‡Ð°ÑÑ‚Ð½Ð¸ÐºÐ¾Ð² Ñ‡Ð°Ñ‚Ð¾Ð² Ð¾ Ñ‚Ð¾Ð¼, Ñ‡Ñ‚Ð¾ Ð¿Ð¾Ð»ÑŒÐ·Ð¾Ð²Ð°Ñ‚ÐµÐ»ÑŒ Ð¾Ð½Ð»Ð°Ð¹Ð½
      this.notifyUserStatusChange(socket.userId, true);

      // ÐžÐ±Ñ€Ð°Ð±Ð¾Ñ‚Ñ‡Ð¸ÐºÐ¸ ÑÐ¾Ð±Ñ‹Ñ‚Ð¸Ð¹
      socket.on('join_chat', (data) => this.handleJoinChat(socket, data));
      socket.on('send_message', (data) => this.handleSendMessage(socket, data));
      socket.on('mark_as_read', (data) => this.handleMarkAsRead(socket, data));
      socket.on('typing_start', (data) => this.handleTypingStart(socket, data));
      socket.on('typing_stop', (data) => this.handleTypingStop(socket, data));

      socket.on('disconnect', () => {
        console.log(`User ${socket.user.name} disconnected:`, socket.id);
        
        // ÐžÐ±Ð½Ð¾Ð²Ð»ÑÐµÐ¼ Ð²Ñ€ÐµÐ¼Ñ Ð¿Ð¾ÑÐ»ÐµÐ´Ð½ÐµÐ¹ Ð°ÐºÑ‚Ð¸Ð²Ð½Ð¾ÑÑ‚Ð¸ Ð¿Ñ€Ð¸ Ð¾Ñ‚ÐºÐ»ÑŽÑ‡ÐµÐ½Ð¸Ð¸
        this.updateUserLastSeen(socket.userId);
        
        // Ð£Ð²ÐµÐ´Ð¾Ð¼Ð»ÑÐµÐ¼ Ð²ÑÐµÑ… ÑƒÑ‡Ð°ÑÑ‚Ð½Ð¸ÐºÐ¾Ð² Ñ‡Ð°Ñ‚Ð¾Ð² Ð¾ Ñ‚Ð¾Ð¼, Ñ‡Ñ‚Ð¾ Ð¿Ð¾Ð»ÑŒÐ·Ð¾Ð²Ð°Ñ‚ÐµÐ»ÑŒ Ð¾Ñ„Ð»Ð°Ð¹Ð½
        this.notifyUserStatusChange(socket.userId, false);
        
        this.userSockets.delete(socket.userId);
        this.socketUsers.delete(socket.id);
      });
    });

    return this.io;
  }

  async joinUserChats(socket) {
    try {
      // ÐÐ°Ñ…Ð¾Ð´Ð¸Ð¼ Ð²ÑÐµ Ñ‡Ð°Ñ‚Ñ‹ Ð¿Ð¾Ð»ÑŒÐ·Ð¾Ð²Ð°Ñ‚ÐµÐ»Ñ
      const userChats = await prisma.chat.findMany({
        where: {
          participants: {
            has: socket.userId
          }
        },
        select: { id: true }
      });

      // ÐŸÑ€Ð¸ÑÐ¾ÐµÐ´Ð¸Ð½ÑÐµÐ¼ Ðº ÐºÐ¾Ð¼Ð½Ð°Ñ‚Ð°Ð¼ Ñ‡Ð°Ñ‚Ð¾Ð²
      userChats.forEach(chat => {
        socket.join(`chat_${chat.id}`);
      });

      console.log(`User ${socket.user.name} joined ${userChats.length} chats`);
    } catch (error) {
      console.error('Error joining user chats:', error);
    }
  }

  async handleJoinChat(socket, data) {
    try {
      const { chatId } = data;
      
      // ÐŸÑ€Ð¾Ð²ÐµÑ€ÑÐµÐ¼, Ñ‡Ñ‚Ð¾ Ð¿Ð¾Ð»ÑŒÐ·Ð¾Ð²Ð°Ñ‚ÐµÐ»ÑŒ ÑƒÑ‡Ð°ÑÑ‚Ð½Ð¸Ðº Ñ‡Ð°Ñ‚Ð°
      const chat = await prisma.chat.findFirst({
        where: {
          id: chatId,
          participants: {
            has: socket.userId
          }
        }
      });

      if (!chat) {
        socket.emit('error', { message: 'Chat not found or access denied' });
        return;
      }

      socket.join(`chat_${chatId}`);
      socket.emit('joined_chat', { chatId });
      
      console.log(`User ${socket.user.name} joined chat ${chatId}`);
    } catch (error) {
      console.error('Error joining chat:', error);
      socket.emit('error', { message: 'Failed to join chat' });
    }
  }

  async handleSendMessage(socket, data) {
    try {
      const { chatId, content } = data;

      // ÐÑÐ¸Ð½Ñ…Ñ€Ð¾Ð½Ð½Ð¾ Ð¾Ð±Ð½Ð¾Ð²Ð»ÑÐµÐ¼ Ð²Ñ€ÐµÐ¼Ñ Ð¿Ð¾ÑÐ»ÐµÐ´Ð½ÐµÐ¹ Ð°ÐºÑ‚Ð¸Ð²Ð½Ð¾ÑÑ‚Ð¸ Ð¿Ð¾Ð»ÑŒÐ·Ð¾Ð²Ð°Ñ‚ÐµÐ»Ñ
      this.updateUserLastSeen(socket.userId);

      // ÐŸÑ€Ð¾Ð²ÐµÑ€ÑÐµÐ¼ Ð´Ð¾ÑÑ‚ÑƒÐ¿ Ðº Ñ‡Ð°Ñ‚Ñƒ Ð¸ ÑÐ¾Ð·Ð´Ð°ÐµÐ¼ ÑÐ¾Ð¾Ð±Ñ‰ÐµÐ½Ð¸Ðµ Ð¿Ð°Ñ€Ð°Ð»Ð»ÐµÐ»ÑŒÐ½Ð¾
      const chatPromise = prisma.chat.findFirst({
        where: {
          id: chatId,
          participants: {
            has: socket.userId
          }
        }
      });

      const messagePromise = prisma.message.create({
        data: {
          content,
          senderId: socket.userId,
          chatId
        }
      });

      const [chat, message] = await Promise.all([chatPromise, messagePromise]);

      if (!chat) {
        socket.emit('error', { message: 'Chat not found or access denied' });
        return;
      }

      // Ð¡Ð¾Ð·Ð´Ð°ÐµÐ¼ ÑÐ¾Ð¾Ð±Ñ‰ÐµÐ½Ð¸Ðµ Ð´Ð»Ñ Ð¾Ñ‚Ð¿Ñ€Ð°Ð²ÐºÐ¸
      const messageWithSender = {
        ...message,
        createdAt: message.createdAt.toISOString(),
        sender: socket.user
      };

      // Ð¡Ñ€Ð°Ð·Ñƒ Ð¾Ñ‚Ð¿Ñ€Ð°Ð²Ð»ÑÐµÐ¼ ÑÐ¾Ð¾Ð±Ñ‰ÐµÐ½Ð¸Ðµ Ð²ÑÐµÐ¼ ÑƒÑ‡Ð°ÑÑ‚Ð½Ð¸ÐºÐ°Ð¼ Ñ‡Ð°Ñ‚Ð°
      this.io.to(`chat_${chatId}`).emit('new_message', messageWithSender);

      // ÐÑÐ¸Ð½Ñ…Ñ€Ð¾Ð½Ð½Ð¾ Ð¾Ð±Ð½Ð¾Ð²Ð»ÑÐµÐ¼ Ð¿Ð¾ÑÐ»ÐµÐ´Ð½ÐµÐµ ÑÐ¾Ð¾Ð±Ñ‰ÐµÐ½Ð¸Ðµ Ð² Ñ‡Ð°Ñ‚Ðµ (Ð½Ðµ Ð¶Ð´ÐµÐ¼ Ð·Ð°Ð²ÐµÑ€ÑˆÐµÐ½Ð¸Ñ)
      prisma.chat.update({
        where: { id: chatId },
        data: {
          lastMessage: content,
          lastMessageAt: new Date()
        }
      }).catch(error => console.error('Error updating chat last message:', error));

      console.log(`Message sent in chat ${chatId} by ${socket.user.name}`);
    } catch (error) {
      console.error('Error sending message:', error);
      socket.emit('error', { message: 'Failed to send message' });
    }
  }

  async handleMarkAsRead(socket, data) {
    try {
      const { messageIds } = data;

      await prisma.message.updateMany({
        where: {
          id: { in: messageIds },
          senderId: { not: socket.userId } // ÐÐµ Ð¾Ñ‚Ð¼ÐµÑ‡Ð°ÐµÐ¼ ÑÐ²Ð¾Ð¸ ÑÐ¾Ð¾Ð±Ñ‰ÐµÐ½Ð¸Ñ ÐºÐ°Ðº Ð¿Ñ€Ð¾Ñ‡Ð¸Ñ‚Ð°Ð½Ð½Ñ‹Ðµ
        },
        data: {
          isRead: true
        }
      });

      // Ð£Ð²ÐµÐ´Ð¾Ð¼Ð»ÑÐµÐ¼ Ð¾Ñ‚Ð¿Ñ€Ð°Ð²Ð¸Ñ‚ÐµÐ»ÐµÐ¹ Ð¾ Ð¿Ñ€Ð¾Ñ‡Ñ‚ÐµÐ½Ð¸Ð¸
      for (const messageId of messageIds) {
        const message = await prisma.message.findUnique({
          where: { id: messageId },
          select: { senderId: true, chatId: true }
        });

        if (message && message.senderId !== socket.userId) {
          const senderSocketId = this.userSockets.get(message.senderId);
          if (senderSocketId) {
            this.io.to(senderSocketId).emit('message_read', {
              messageId,
              readBy: socket.userId,
              chatId: message.chatId
            });
          }
        }
      }

      console.log(`Messages marked as read by ${socket.user.name}`);
    } catch (error) {
      console.error('Error marking messages as read:', error);
    }
  }

  handleTypingStart(socket, data) {
    const { chatId } = data;
    socket.to(`chat_${chatId}`).emit('user_typing_start', {
      userId: socket.userId,
      userName: socket.user.name,
      chatId
    });
  }

  handleTypingStop(socket, data) {
    const { chatId } = data;
    socket.to(`chat_${chatId}`).emit('user_typing_stop', {
      userId: socket.userId,
      chatId
    });
  }

  // ÐœÐµÑ‚Ð¾Ð´ Ð´Ð»Ñ Ð¾Ñ‚Ð¿Ñ€Ð°Ð²ÐºÐ¸ ÑÐ¾Ð¾Ð±Ñ‰ÐµÐ½Ð¸Ñ ÐºÐ¾Ð½ÐºÑ€ÐµÑ‚Ð½Ð¾Ð¼Ñƒ Ð¿Ð¾Ð»ÑŒÐ·Ð¾Ð²Ð°Ñ‚ÐµÐ»ÑŽ
  sendToUser(userId, event, data) {
    const socketId = this.userSockets.get(userId);
    if (socketId) {
      this.io.to(socketId).emit(event, data);
      return true;
    }
    return false;
  }

  // ÐœÐµÑ‚Ð¾Ð´ Ð´Ð»Ñ Ð¿Ð¾Ð»ÑƒÑ‡ÐµÐ½Ð¸Ñ Ð¾Ð½Ð»Ð°Ð¹Ð½ Ð¿Ð¾Ð»ÑŒÐ·Ð¾Ð²Ð°Ñ‚ÐµÐ»ÐµÐ¹
  getOnlineUsers() {
    return Array.from(this.userSockets.keys());
  }

  // ÐœÐµÑ‚Ð¾Ð´ Ð´Ð»Ñ Ð¿Ñ€Ð¾Ð²ÐµÑ€ÐºÐ¸, Ð¾Ð½Ð»Ð°Ð¹Ð½ Ð»Ð¸ Ð¿Ð¾Ð»ÑŒÐ·Ð¾Ð²Ð°Ñ‚ÐµÐ»ÑŒ
  isUserOnline(userId) {
    return this.userSockets.has(userId);
  }

  // Ð£Ð²ÐµÐ´Ð¾Ð¼Ð»ÐµÐ½Ð¸Ðµ Ð¾Ð± Ð¸Ð·Ð¼ÐµÐ½ÐµÐ½Ð¸Ð¸ Ð¾Ð½Ð»Ð°Ð¹Ð½ ÑÑ‚Ð°Ñ‚ÑƒÑÐ° Ð¿Ð¾Ð»ÑŒÐ·Ð¾Ð²Ð°Ñ‚ÐµÐ»Ñ
  async notifyUserStatusChange(userId, isOnline) {
    try {

      
      // ÐÐ°Ñ…Ð¾Ð´Ð¸Ð¼ Ð²ÑÐµ Ñ‡Ð°Ñ‚Ñ‹ Ð¿Ð¾Ð»ÑŒÐ·Ð¾Ð²Ð°Ñ‚ÐµÐ»Ñ
      const userChats = await prisma.chat.findMany({
        where: {
          participants: {
            has: userId
          }
        },
        select: { id: true, participants: true }
      });



      let notificationsSent = 0;
      // Ð£Ð²ÐµÐ´Ð¾Ð¼Ð»ÑÐµÐ¼ Ð²ÑÐµÑ… ÑƒÑ‡Ð°ÑÑ‚Ð½Ð¸ÐºÐ¾Ð² ÑÑ‚Ð¸Ñ… Ñ‡Ð°Ñ‚Ð¾Ð² Ð¾Ð± Ð¸Ð·Ð¼ÐµÐ½ÐµÐ½Ð¸Ð¸ ÑÑ‚Ð°Ñ‚ÑƒÑÐ°
      userChats.forEach(chat => {
        chat.participants.forEach(participantId => {
          if (participantId !== userId) {
            const participantSocketId = this.userSockets.get(participantId);
            if (participantSocketId) {
              this.io.to(participantSocketId).emit('user_status_change', {
                userId,
                isOnline,
                chatId: chat.id
              });
              notificationsSent++;
              console.log(`   âœ… Sent status to participant ${participantId} (socket: ${participantSocketId})`);
            } else {
              console.log(`   âš ï¸  Participant ${participantId} is OFFLINE (no socket)`);
            }
          }
        });
      });

      console.log(`ðŸ“¡ Status change notifications sent: ${notificationsSent}`);
    } catch (error) {
      console.error('Error notifying user status change:', error);
    }
  }

  // ÐžÐ±Ð½Ð¾Ð²Ð»ÐµÐ½Ð¸Ðµ Ð²Ñ€ÐµÐ¼ÐµÐ½Ð¸ Ð¿Ð¾ÑÐ»ÐµÐ´Ð½ÐµÐ¹ Ð°ÐºÑ‚Ð¸Ð²Ð½Ð¾ÑÑ‚Ð¸ Ð¿Ð¾Ð»ÑŒÐ·Ð¾Ð²Ð°Ñ‚ÐµÐ»Ñ
  async updateUserLastSeen(userId) {
    try {
      await prisma.user.update({
        where: { id: userId },
        data: { lastSeen: new Date() }
      });
    } catch (error) {
      console.error('Error updating user last seen:', error);
    }
  }
}

const socketManager = new SocketManager();
socketManager.init(httpServer);

// Health check
app.get('/health', (req, res) => {
  res.json({ 
    status: 'ok', 
    service: 'chat-socket-service',
    connectedUsers: socketManager.getOnlineUsers().length,
    uptime: process.uptime()
  });
});

// ÐŸÑ€Ð¾Ð²ÐµÑ€ÐºÐ° ÑÑ‚Ð°Ñ‚ÑƒÑÐ° Ð¿Ð¾Ð»ÑŒÐ·Ð¾Ð²Ð°Ñ‚ÐµÐ»Ñ
app.get('/api/users/:userId/online', (req, res) => {
  const { userId } = req.params;
  const isOnline = socketManager.isUserOnline(userId);
  res.json({ userId, isOnline });
});

// ÐœÐ°ÑÑÐ¾Ð²Ð°Ñ Ð¿Ñ€Ð¾Ð²ÐµÑ€ÐºÐ° ÑÑ‚Ð°Ñ‚ÑƒÑÐ¾Ð² (Ð´Ð»Ñ ÑÐ¿Ð¸ÑÐºÐ° Ñ‡Ð°Ñ‚Ð¾Ð²)
app.post('/api/users/online-status', express.json(), (req, res) => {
  const { userIds } = req.body;
  
  if (!Array.isArray(userIds)) {
    return res.status(400).json({ error: 'userIds must be an array' });
  }

  const statuses = userIds.reduce((acc, userId) => {
    acc[userId] = socketManager.isUserOnline(userId);
    return acc;
  }, {});

  res.json(statuses);
});

const PORT = process.env.PORT || 3002;

httpServer.listen(PORT, () => {
  console.log(`ðŸš€ Chat Socket Service running on port ${PORT}`);
  console.log(`ðŸ“¡ Socket.IO endpoint: ws://localhost:${PORT}`);
  console.log(`ðŸ”— Connected users: ${socketManager.getOnlineUsers().length}`);
});
